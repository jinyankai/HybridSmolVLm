import torch

from typing import List, Optional, Tuple, Union

from transformers.modeling_flash_attention_utils import FlashAttentionKwargs


from transformers.models.smolvlm.modeling_smolvlm import (SmolVLMModel,
                                                          SmolVLMBaseModelOutputWithPast, logger,
                                                          DynamicCache, SmolVLMConfig,
                                                          SmolVLMForConditionalGeneration, KwargsForCausalLM,
                                                          SmolVLMCausalLMOutputWithPast)
from transformers.processing_utils import Unpack
from transformers.masking_utils import create_causal_mask
from .decoder_layer import HybridDecoderLayers
import dataclasses
from typing import Dict

@dataclasses.dataclass
class DistillationModelOutput(SmolVLMBaseModelOutputWithPast):
    distillation_alignment_outputs: Optional[Dict[int, Tuple[torch.Tensor, torch.Tensor]]] = None

class Hybrid_SmolVLM(SmolVLMModel):
    def __init__(self,config : SmolVLMConfig):
        super().__init__(config)
        self.gradient_checkpointing = True

    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_values: Optional[list[torch.FloatTensor]] = None,
        inputs_embeds: Optional[torch.FloatTensor] = None,
        pixel_values: Optional[torch.FloatTensor] = None,
        pixel_attention_mask: Optional[torch.BoolTensor] = None,
        image_hidden_states: Optional[torch.FloatTensor] = None,
        use_cache: Optional[bool] = None,
        output_attentions: Optional[bool] = None,
        output_hidden_states: Optional[bool] = None,
        return_dict: Optional[bool] = None,
        cache_position: Optional[torch.LongTensor] = None,
        teacher_outputs = None,
        distillation_layers: Optional[List[int]] = None,
        **kwargs: Unpack[FlashAttentionKwargs],
    ) :
        r"""
                pixel_attention_mask (`torch.Tensor` of shape `(batch_size, image_size, image_size)`, *optional*):
                    Mask to avoid performing attention on padding pixel indices.
                image_hidden_states (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):
                    The hidden states of the image encoder after modality projection.
                """
        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions
        output_hidden_states = (
            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states
        )
        use_cache = use_cache if use_cache is not None else self.config.use_cache
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        if self.training and self.text_model.gradient_checkpointing and use_cache:
            logger.warning_once(
                "`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`..."
            )
            use_cache = False

        # retrieve input_ids and inputs_embeds
        if input_ids is not None:
            batch_size, seq_length = input_ids.shape
        elif inputs_embeds is not None:
            batch_size, seq_length, _ = inputs_embeds.shape
        else:
            raise ValueError("You have to specify either input_ids or inputs_embeds")

        past_seen_tokens = 0
        if use_cache:
            if past_key_values is None:
                past_key_values = DynamicCache()
            past_seen_tokens = past_key_values.get_seq_length()

        if inputs_embeds is not None and input_ids is None and past_seen_tokens == 0:
            raise ValueError("When first calling the model, if input_embeds are passed, input_ids should not be None.")

        if inputs_embeds is None:
            inputs_embeds = self.text_model.get_input_embeddings()(input_ids).to(input_ids.device)

        # START VISUAL INPUTS INTEGRATION
        if pixel_values is not None and image_hidden_states is not None:
            raise ValueError("You cannot specify both pixel_values and image_hidden_states at the same time")
        elif pixel_values is not None:
            image_hidden_states = self.get_image_features(pixel_values, pixel_attention_mask).to(input_ids.device)
        elif image_hidden_states is not None:
            image_hidden_states = image_hidden_states.to(dtype=self.dtype, device=input_ids.device)

        if inputs_embeds is not None and image_hidden_states is not None:
            # When we generate, we don't want to replace the potential image_token_id that we generated by images
            # that simply don't exist
            inputs_embeds = self.inputs_merger(
                input_ids=input_ids,
                inputs_embeds=inputs_embeds,
                image_hidden_states=image_hidden_states,
            )

        if teacher_outputs is None:

            outputs = self.text_model(
                inputs_embeds=inputs_embeds,
                attention_mask=attention_mask,
                position_ids=position_ids,
                past_key_values=past_key_values,
                use_cache=use_cache,
                output_attentions=output_attentions,
                output_hidden_states=output_hidden_states,
                return_dict=True,
                cache_position=cache_position,
                **kwargs,
            )
            return DistillationModelOutput(
                last_hidden_state=outputs.last_hidden_state,
                past_key_values=outputs.past_key_values,
                hidden_states=outputs.hidden_states,
                attentions=outputs.attentions,
                image_hidden_states=image_hidden_states,
                distillation_alignment_outputs=None
            )
        else:
        # # NEW VERSION FOR DISTILLATION
            if cache_position is None:
                past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0
                cache_position = torch.arange(
                    past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device
                )

            if position_ids is None:
                position_ids = cache_position.unsqueeze(0)

            causal_mask = create_causal_mask(
                config=self.config,
                input_embeds=inputs_embeds,
                attention_mask=attention_mask,
                cache_position=cache_position,
                past_key_values=past_key_values,
                position_ids=position_ids,
            )

            hidden_states = inputs_embeds

            # create position embeddings to be shared across the decoder layers
            all_hidden_states = () if output_hidden_states else None
            all_teacher_hidden_states = (
            teacher_outputs[0],) if output_hidden_states and teacher_outputs is not None else None
            all_self_attns = () if output_attentions else None
            next_decoder_cache = None
            ## Build Position embeddings
            position_embeddings = self.text_model.rotary_emb(hidden_states,position_ids)
            distillation_outputs = {}

            mamba_layer_id = 0
            self.layers = self.text_model.layers
            for layer_id, decoder_layer in enumerate(self.layers):
                if output_hidden_states:
                    all_hidden_states += (hidden_states,)
                if isinstance(decoder_layer, HybridDecoderLayers):
                    mamba_layer_id += 1

                hidden_states_run = [hidden_states]
                if teacher_outputs is not None:
                    teacher_hidden_states = teacher_outputs[layer_id]
                    hidden_states_run.append(teacher_hidden_states)

                hidden_states_out = []
                for layer_id, decoder_layer in enumerate(self.layers):
                    if output_hidden_states:
                        all_hidden_states += (hidden_states,)

                    # --- 【核心逻辑】如果当前层是需要对齐的层 ---
                    if distillation_layers and layer_id in distillation_layers and self.gradient_checkpointing and self.training:
                        # 1. 获取老师的输入 (即老师前一层的输出)
                        teacher_input_state = teacher_outputs[layer_id]
                        # 2. 将老师的输入送入当前学生层
                        student_output_from_teacher_input = self._gradient_checkpointing_func(
                            decoder_layer.__call__,
                            teacher_input_state,  # 第1个参数: hidden_states
                            causal_mask,  # 第2个参数: attention_mask
                            position_ids,  # 第3个参数: position_ids
                            past_key_values,  # 第4个参数: past_key_value
                            output_attentions,  # 第5个参数: output_attentions
                            use_cache,  # 第6个参数: use_cache
                            cache_position,  # 第7个参数: cache_position
                            position_embeddings,  # 第8个参数: position_embeddings
                        )[0]  # 取 hidden_states
                        # 3. 获取老师的输出 (对齐的目标)
                        teacher_output_state = teacher_outputs[layer_id + 1]

                        # 4. 存储这对儿，用于后续计算 L2 loss
                        distillation_outputs[layer_id] = (student_output_from_teacher_input, teacher_output_state)

                    # --- 学生模型正常的前向传播 ---
                    # (这里的 gradient checkpointing 逻辑不变)
                    layer_outputs = decoder_layer(
                            hidden_states,
                            attention_mask=causal_mask,
                            position_ids=position_ids,
                            past_key_value=past_key_values,
                            output_attentions=output_attentions,
                            use_cache=use_cache,
                            cache_position=cache_position,
                            position_embeddings=position_embeddings,)
                    hidden_states = layer_outputs[0]
                    hidden_states_out.append(layer_outputs[0])

                hidden_states = hidden_states_out[0]  # type: ignore

                if teacher_outputs is not None and output_hidden_states and layer_id != len(self.layers) - 1:
                    all_teacher_hidden_states += (hidden_states_out[1],)

                if use_cache:
                    next_decoder_cache = layer_outputs[2 if output_attentions else 1]

                if output_attentions:
                    all_self_attns += (layer_outputs[1],)

            hidden_states = self.text_model.norm(hidden_states)

            # add hidden states from the last decoder layer
            if output_hidden_states:
                all_hidden_states += (hidden_states,)


            return DistillationModelOutput(
                last_hidden_state=hidden_states,
                past_key_values=next_decoder_cache,
                hidden_states=all_hidden_states,
                attentions=all_self_attns,
                image_hidden_states=image_hidden_states,
                distillation_alignment_outputs=distillation_outputs
            )

@dataclasses.dataclass
class HybridOutputCausalLM(SmolVLMCausalLMOutputWithPast):
    # ...
    distillation_alignment_outputs: Optional[Dict[int, Tuple[torch.Tensor, torch.Tensor]]] = None


class HybridSmolVLMForConditionalGeneration(SmolVLMForConditionalGeneration):
    def __init__(self,config:SmolVLMConfig):
        super().__init__(config)
        self.model = Hybrid_SmolVLM(config)
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = None,
        attention_mask: Optional[torch.Tensor] = None,
        position_ids: Optional[torch.LongTensor] = None,
        past_key_values: Optional[list[torch.FloatTensor]] = None,
        inputs_embeds: Optional[torch.FloatTensor] = None,
        pixel_values: Optional[torch.FloatTensor] = None,
        pixel_attention_mask: Optional[torch.BoolTensor] = None,
        image_hidden_states: Optional[torch.FloatTensor] = None,
        labels: Optional[torch.LongTensor] = None,
        use_cache: Optional[bool] = None,
        output_attentions: Optional[bool] = None,
        output_hidden_states: Optional[bool] = None,
        cache_position: Optional[torch.LongTensor] = None,
        return_dict: Optional[bool] = None,
        logits_to_keep: Union[int, torch.Tensor] = 0,
        teacher_outputs = None,
        distillation_layers: Optional[List[int]] = None,
        **kwargs: Unpack[KwargsForCausalLM],
    ) -> Union[tuple, SmolVLMCausalLMOutputWithPast]:
        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions
        output_hidden_states = (
            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states
        )
        return_dict = return_dict if return_dict is not None else self.config.use_return_dict

        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)
        outputs = self.model(
            input_ids=input_ids,
            attention_mask=attention_mask,
            position_ids=position_ids,
            past_key_values=past_key_values,
            inputs_embeds=inputs_embeds,
            pixel_values=pixel_values,
            pixel_attention_mask=pixel_attention_mask,
            image_hidden_states=image_hidden_states,
            use_cache=use_cache,
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            cache_position=cache_position,
            return_dict=True,
            teacher_outputs=teacher_outputs,
            distillation_layers=distillation_layers,
            **kwargs,
        )


        hidden_states = outputs[0]
        if isinstance(hidden_states, (tuple, list)):
            hidden_states = hidden_states[0]
        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss
        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep
        logits = self.lm_head(hidden_states[:, slice_indices, :])

        loss = None
        if labels is not None:
            loss = self.loss_function(
                logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size, **kwargs
            )

        return HybridOutputCausalLM(
            loss=loss,
            logits=logits,
            past_key_values=outputs.past_key_values,
            hidden_states=outputs.hidden_states,
            attentions=outputs.attentions,
            image_hidden_states=outputs.image_hidden_states,
            distillation_alignment_outputs=outputs.distillation_alignment_outputs
        )
